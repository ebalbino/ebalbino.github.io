<!DOCTYPE html>
<html><head lang="en"><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title> - Grimoire Black</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="Currently I&rsquo;m programming a game in my free time. One of my first problems is asset management. A game has to load various different sounds, images, models, animations, etc.
In the case of images, we will need to possibly handle.

BMP
JPG
PNG
PSD
TIFF

Each format requires a method for parsing the contents of these files, retrieving information and extracting a bitmap. At maximum, this brings 5 dependencies into my project. Each dependency will require me to implement three functions at minimum. That&rsquo;s 15 functions now. In the future, it can be 30." />
	<meta property="og:image" content="http://localhost:1313/"/>
	<meta property="og:url" content="http://localhost:1313/applying-the-unix-philosophy/">
  <meta property="og:site_name" content="Grimoire Black">
  <meta property="og:title" content="Grimoire Black">
  <meta property="og:description" content="Currently I’m programming a game in my free time. One of my first problems is asset management. A game has to load various different sounds, images, models, animations, etc.
In the case of images, we will need to possibly handle.
BMP JPG PNG PSD TIFF Each format requires a method for parsing the contents of these files, retrieving information and extracting a bitmap. At maximum, this brings 5 dependencies into my project. Each dependency will require me to implement three functions at minimum. That’s 15 functions now. In the future, it can be 30.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Grimoire Black">
  <meta name="twitter:description" content="Currently I’m programming a game in my free time. One of my first problems is asset management. A game has to load various different sounds, images, models, animations, etc.
In the case of images, we will need to possibly handle.
BMP JPG PNG PSD TIFF Each format requires a method for parsing the contents of these files, retrieving information and extracting a bitmap. At maximum, this brings 5 dependencies into my project. Each dependency will require me to implement three functions at minimum. That’s 15 functions now. In the future, it can be 30.">

        <link href="http://localhost:1313/css/fonts.2c2227b81b1970a03e760aa2e6121cd01f87c88586803cbb282aa224720a765f.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="http://localhost:1313/css/main.a87126a5d38398207e58225b2d1a9faf97f546982f44b3ffb9715a264da36c90.css" />
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="http://localhost:1313/">Grimoire Black</a>
	</div>
	<nav>
		
		
	</nav>
</header>

<main>
  <article>
    <div class="post-container">
      
      <div class="post-content">
        <div class="title">
          <h1 class="title"></h1>
          <div class="meta">Posted on Jan 1, 1</div>
        </div>
        
        <section class="body">
          <p>Currently I&rsquo;m programming a game in my free time. One of my first problems is asset management. A game has to load various different sounds, images, models, animations, etc.</p>
<p>In the case of images, we will need to possibly handle.</p>
<ul>
<li>BMP</li>
<li>JPG</li>
<li>PNG</li>
<li>PSD</li>
<li>TIFF</li>
</ul>
<p>Each format requires a method for parsing the contents of these files, retrieving information and extracting a bitmap. At maximum, this brings 5 dependencies into my project. Each dependency will require me to implement three functions at minimum. That&rsquo;s 15 functions now. In the future, it can be 30.</p>
<p>That&rsquo;s a lot of code just to support image loading. Do I want to take on writing all that code and maintaining it? What if I have to support a new format in the future? That&rsquo;s one more dependency to manage and more code to maintain.</p>
<p>Most importantly, this application is first and foremost a game. A game shouldn&rsquo;t need to worry about file formats. It only uses the RGB/RGBA values inside those formats.</p>
<p>With that in mind, I decided against linking libraries to support image loading in the asset management module. In the context of the game, an image is a binary blob of RGB/RGBA values. That will be its representation at runtime and on disk.</p>
<p>To facilitate this requirement, we&rsquo;ll add a new step to our project&rsquo;s build. All image files will be converted into raw binary blobs.</p>
<p>We can accomplish this with two programs.</p>
<h3 id="image-processing-with-imagemagick">Image processing with ImageMagick</h3>
<p>ImageMagick supports a wide range of image formats. Most importantly, it supports converting images to the <code>.rgb</code> and <code>.rgba</code> formats i.e. raw binary blobs.</p>
<p><code>imagemagick -depth 8 image.png image.rgba</code>
<code>imagemagick -depth 8 image.jpg image.rgba</code>
<code>imagemagick -depth 8 image.bmp image.rgba</code>
<code>imagemagick -depth 8 image.tiff image.rgba</code>
<code>imagemagick -depth 8 image.psd image.rgba</code></p>
<p>We also get more bang for our buck. ImageMagick supports much more than the previously listed formats.</p>
<h3 id="building-with-make">Building with Make</h3>
<p>Make allows us to avoid writing a separate command for each image. It defines targets and implicit rules to manage our build.</p>
<p>Targets are the output of a build. In my scenario, the targets are <code>.rgb</code> and <code>.rgba</code> files. Other file formats will be used to build these targets.</p>
<p>Through an implicit rule, we can associate a file format to a target.</p>
<pre tabindex="0"><code>%.rgba: %.png
	@echo $&lt; $@
</code></pre><p>With this rule in our Makefile, if we run the command:</p>
<p><code>make test.rgba</code></p>
<p>If the file <code>test.png</code> exists, then the echo command will run and output.</p>
<p><code>test.png test.rgba</code></p>
<p>If a target doesn&rsquo;t have its depedencies, then the output will be:</p>
<p><code>make: *** No rule to make target 'test.rgb'.  Stop.</code></p>
<p>In our rule&rsquo;s recipe (the part with the echo command), we use two variables: <code>$@</code> and <code>$&lt;</code></p>
<ul>
<li><code>$@</code> The target</li>
<li><code>$&lt;</code> Our dependency i.e. the file used to build the target</li>
</ul>
<p>These variables are expanded respectively to:</p>
<ul>
<li><code>test.rgba</code></li>
<li><code>test.png</code></li>
</ul>
<p>With this, we can build an ImageMagick command for converting our files.</p>
<pre tabindex="0"><code>%.rgba: %.png
	@magick -depth 8 $&lt; $@
</code></pre><p>We can repeat this rule but with different prerequisites in our dependencies.</p>
<pre tabindex="0"><code>%.rgba: %.jpg
	@magick -depth 8 $&lt; $@
	
%.rgba: %.tiff
	@magick -depth 8 $&lt; $@

%.rgba: %.psd
	@magick -depth 8 $&lt; $@
	
%.rgba: %.bmp
	@magick -depth 8 $&lt; $@
</code></pre><p>Now when <code>make test.rgba</code> is run, it will search for:</p>
<ul>
<li><code>test.png</code></li>
<li><code>test.jpg</code></li>
<li><code>test.tiff</code></li>
<li><code>test.psd</code></li>
<li><code>test.bmp</code></li>
</ul>
<p>The first match it finds is used to build <code>test.rgba</code>. If a match isn&rsquo;t found, the same error as before is displayed. If two files of different formats have the same basename, Make can present inconsistent behavior so that&rsquo;s an edge case we need to remember and avoid.</p>
<p>Earlier I mentioned that Make helps us avoid repeating commands. Now that we&rsquo;ve defined our rules. We just need to define a few variables to accomplish that.</p>
<pre tabindex="0"><code>JPEGS = $(wildcard *.jpg)
PNGS = $(wildcard *.png)
TIFFS = $(wildcard *.tiff)
PSDS = $(wildcard *.psd)
BMPS = $(wildcard *.bmp)
</code></pre><p>The <code>wildcard</code> function expands to all of the files in the directory the Makefile is located in that match the expression.</p>
<p>With the <code>patsubst</code> function, we can change the extensions of all the matched files to the <code>.rgba</code> target that we want to build.</p>
<p><code>$(patsubst %.jpg,%.rgba,$(JPEGS))</code></p>
<p>For example, if we have:</p>
<ul>
<li><code>example-1.jpg</code></li>
<li><code>example-2.jpg</code></li>
</ul>
<p><code>patsubst</code> would return a new list with:</p>
<ul>
<li><code>example-1.rgba</code></li>
<li><code>example-2.rgba</code></li>
</ul>
<p>This can also be written as:</p>
<p><code>$(JPEGS:.jpg=.rgba)</code></p>
<p>You&rsquo;ll probably see the shorthand more often than <code>patsubst</code> in the wild.</p>
<p>With this we can create a new target <code>build_rgba</code></p>
<p><code>build_rgba: $(JPEGS:.jpg=.rgba) $(PNGS:.png=.rgba) $(TIFFS:.tiff=.rgba) $(PSD:.psd=.rgba) $(BMPS:.bmp=.rgba)</code></p>
<p><code>build_rgba</code>&rsquo;s dependencies are expanded when Make is run. The expansion will generate a list of <code>.rgba</code> files from all of the images found in the directory. Each file in that list will match against one of the rules we defined and execute a command.</p>
<p>With support for both <code>.rgb</code> and <code>.rgba</code> files, this is our final <code>Makefile</code></p>
<pre tabindex="0"><code>JPEGS = $(wildcard *.jpg)
PNGS = $(wildcard *.png)
TIFFS = $(wildcard *.tiff)
PSDS = $(wildcard *.psd)
BMPS = $(wildcard *.bmp)

%.rgb: %.png
	@echo &#34;Building&#34; $@
	@magick -depth 8 $&lt; $@

%.rgb: %.jpg
	@echo &#34;Building&#34; $@
	@magick -depth 8 $&lt; $@

%.rgb: %.tiff
	@echo &#34;Building&#34; $@
	@magick -depth 8 $&lt; $@

%.rgb: %.psd
	@echo &#34;Building&#34; $@
	@magick -depth 8 $&lt; $@

%.rgb: %.bmp
	@echo &#34;Building&#34; $@
	@magick -depth 8 $&lt; $@

%.rgba: %.png
	@echo &#34;Building&#34; $@
	@magick -depth 8 $&lt; $@

%.rgba: %.jpg
	@echo &#34;Building&#34; $@
	@magick -depth 8 $&lt; $@

%.rgba: %.tiff
	@echo &#34;Building&#34; $@
	@magick -depth 8 $&lt; $@

%.rgba: %.psd
	@echo &#34;Building&#34; $@
	@magick -depth 8 $&lt; $@

%.rgba: %.bmp
	@echo &#34;Building&#34; $@
	@magick -depth 8 $&lt; $@

build_rgb: $(JPEGS:.jpg=.rgb) $(PNGS:.png=.rgb) $(TIFFS:.tiff=.rgb) $(PSD:.psd=.rgb) $(BMPS:.bmp=.rgb) 
build_rgba: $(JPEGS:.jpg=.rgba) $(PNGS:.png=.rgba) $(TIFFS:.tiff=.rgba) $(PSD:.psd=.rgba) $(BMPS:.bmp=.rgba) 

.PHONY: build
build: build_rgba 
	@echo &#34;Image data extracted.&#34;

.PHONY: clean
clean:
	rm *.rgb *.rgba *.size
</code></pre><p>In just under 60 lines of code, we&rsquo;ve built a pipeline that processes multiple image formats and can be expanded easily. It&rsquo;s definitely much less than all the code I would&rsquo;ve written to support image loading at runtime. Definitely by an order of magnitude.</p>
<p>Depending on Make gives more benefits. This build updates automatically when a new file is added to the directory or whenever a file has been modified. We also get parallelism for free.</p>
<p>With the <code>-j</code> argument, Make can run multiple jobs at once.</p>
<pre tabindex="0"><code>make build -j8 # Use 8 cores for building targets
make build -j # Use all cores available
</code></pre><p>With this, it becomes clearer that applying the Unix philosophy isn&rsquo;t just about piping one program&rsquo;s output to another&rsquo;s input. It&rsquo;s about keeping our programs focused on completing simple objectives. My game isn&rsquo;t an image loader. It has to deal with data loaded from images. Through that simple change in perspective, it was possible to create a better solution that keeps my game code simpler to maintain and focused on what it actually needs to be: fun</p>

        </section>
        <div class="post-tags">
          
        </div>
      </div>

      
      
    </div>

    </article>
</main>
<footer>
  <div style="display:flex"></div>
  <div class="footer-info">
    2026  <a
      href="https://github.com/athul/archie">Archie Theme</a> | Built with <a href="https://gohugo.io">Hugo</a>
  </div>
</footer>

</div>
    </body>
</html>
