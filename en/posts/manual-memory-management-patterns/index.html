<!DOCTYPE html>
<html><head lang="en">
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Manual memory management patterns - Defined Behavior</title><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="Manual memory management has a nasty reputation.
I get it.
You&rsquo;re a developer. You&rsquo;re looking to put another trick in your bag. You look up the most popular languages of the year. You glaze over the results and something stands out.
So many languages have been made just to avoid manual memory management.
It sends a clear message. Here there be dragons.
I like to separate manual memory management into two groups:" />
	<meta property="og:image" content="https://ebalbino.github.io/"/>
	<meta property="og:url" content="https://ebalbino.github.io/en/posts/manual-memory-management-patterns/">
  <meta property="og:site_name" content="Defined Behavior">
  <meta property="og:title" content="Manual memory management patterns">
  <meta property="og:description" content="Manual memory management has a nasty reputation.
I get it.
You’re a developer. You’re looking to put another trick in your bag. You look up the most popular languages of the year. You glaze over the results and something stands out.
So many languages have been made just to avoid manual memory management.
It sends a clear message. Here there be dragons.
I like to separate manual memory management into two groups:">
  <meta property="og:locale" content="en_US">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2026-01-23T00:00:00+00:00">
    <meta property="article:modified_time" content="2026-01-23T00:00:00+00:00">
    <meta property="article:tag" content="Programming">
    <meta property="article:tag" content="Rust">
    <meta property="article:tag" content="Memory-Management">
    <meta property="article:tag" content="Arena">
    <meta property="article:tag" content="Pointers">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Manual memory management patterns">
  <meta name="twitter:description" content="Manual memory management has a nasty reputation.
I get it.
You’re a developer. You’re looking to put another trick in your bag. You look up the most popular languages of the year. You glaze over the results and something stands out.
So many languages have been made just to avoid manual memory management.
It sends a clear message. Here there be dragons.
I like to separate manual memory management into two groups:">

        <link href="https://ebalbino.github.io/css/fonts.12e4c53a83fc26e89e26f25b4e82afa665058e3ffa3a62c7c7eebb308921ceb7.css" rel="stylesheet">
	

	
	<link rel="stylesheet" type="text/css" media="screen" href="https://ebalbino.github.io/css/main.411dccf228c6d875252abf3706f67d6f666a0529759a2a7586820e17229d0d07.css" />
		<link id="darkModeStyle" rel="stylesheet" type="text/css" href="https://ebalbino.github.io/css/dark.f163b79c6de51d14a766ff9f0563053de7f06a4d1bf7b85a59608bf96e566710.css"  disabled /><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Roboto+Serif:ital,opsz,wght@0,8..144,100..900;1,8..144,100..900&display=swap" rel="stylesheet">

	
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://ebalbino.github.io/en/">Defined Behavior</a>
	</div>
	<nav>
		
		<a href="/">Home</a>
		
		<a href="/en/posts">Blog</a>
		
		<a href="/en/about">About</a>
		
		<a href="/en/tags">Tags</a>
		
		<button id="dark-mode-toggle" class="nav-toggle" onclick="toggleTheme()" aria-label="Toggle dark mode" type="button"><svg class="feather" viewBox="0 0 24 24" fill="none" stroke="#232333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg></button>
		<script src="https://ebalbino.github.io/js/themetoggle.js"></script>
		
	</nav>
</header>

<main>
  <article>
    <div class="post-container">
      
      <div class="post-content">
        <div class="title">
          <h1 class="title">Manual memory management patterns</h1>
          <div class="meta">Posted on Jan 23, 2026</div>
        </div>
        
        <section class="body">
          <p>Manual memory management has a nasty reputation.</p>
<p>I get it.</p>
<p>You&rsquo;re a developer. You&rsquo;re looking to put another trick in your bag. You look up the most popular languages of the year. You glaze over the results and something stands out.</p>
<p><em>So many languages have been made just to avoid manual memory management.</em></p>
<p>It sends a clear message. <em>Here there be dragons</em>.</p>
<p>I like to separate manual memory management into two groups:</p>
<ul>
<li>Memory management in static processes</li>
<li>Memory management in dynamic processes</li>
</ul>
<p>Manual memory management in dynamic processes is usually the dragon that people are avoiding. Dynamic processes are those that run indefinitely. Until a signal is sent to stop execution, the process is always running. Consequentially allocation state has to be maintained at all times to avoid leaks.</p>
<p>This is what attracts people to garbage collectors. It adds a synchronous moment in the program&rsquo;s execution where everything is halted so clean up can occur. While there are many scenarios where that cannot be allowed, it <strong>is</strong> a trade-off the majority are willing to make. Unless necessary, most people would rather not manage the alternative&rsquo;s complexity.</p>
<p>On the other hand, manual memory management in <strong>static processes</strong> is much simpler to grasp. Regardless of how much time the execution takes, the fact that it terminates <em>eventually</em> simplifies implementation. Most code in this scenario can allocate onto a fixed-size buffer. Eventually it&rsquo;ll have to deal with an input that causes the buffer to overflow. But that&rsquo;s a simple error to handle. You&rsquo;d be surprised how often doubling the buffer size is enough of a solution.</p>
<p>Let’s walk through a simple arena implementation, why it’s structured the way it is, and what tradeoffs it makes along the way.</p>
<hr>
<h2 id="one-buffer-to-rule-them-all-one-cursor-to-find-them">One buffer to rule them all, one cursor to find them</h2>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#427b58">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#af3a03">pub</span> <span style="color:#af3a03">struct</span> Arena {
</span></span><span style="display:flex;"><span>    buffer: <span style="color:#b57614">Box</span><span style="color:#af3a03">&lt;</span>[<span style="color:#b57614">u8</span>]<span style="color:#af3a03">&gt;</span>,
</span></span><span style="display:flex;"><span>    cursor: Cell<span style="color:#af3a03">&lt;</span><span style="color:#b57614">usize</span><span style="color:#af3a03">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#af3a03">pub</span> <span style="color:#af3a03">fn</span> <span style="color:#b57614">arena</span>(capacity: <span style="color:#b57614">usize</span>) -&gt; Rc<span style="color:#af3a03">&lt;</span>Arena<span style="color:#af3a03">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#af3a03">let</span> buffer <span style="color:#af3a03">=</span> <span style="color:#af3a03">unsafe</span> { <span style="color:#b57614">Box</span>::<span style="color:#af3a03">&lt;</span>[<span style="color:#b57614">u8</span>]<span style="color:#af3a03">&gt;</span>::new_zeroed_slice(capacity).assume_init() };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Rc::new(Arena {
</span></span><span style="display:flex;"><span>        buffer,
</span></span><span style="display:flex;"><span>        cursor: Cell::new(<span style="color:#8f3f71">0</span>),
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>An arena is just:</p>
<ul>
<li>one big <code>Box&lt;[u8]&gt;</code></li>
<li>one <code>cursor</code> that says “the next free byte is here”</li>
</ul>
<p>Every allocation:</p>
<ol>
<li>grabs some bytes starting at the cursor</li>
<li>bumps the cursor forward</li>
</ol>
<p>No free lists. No per-object overhead. And simple to wrap.</p>
<p>The cursor lives in a <code>Cell&lt;usize&gt;</code>, which lets us mutate it even through <code>&amp;self</code>. That’s intentional.  Allocating shouldn’t require a unique borrow of the entire arena. Since this Arena will be shared as an <code>Rc</code> smart pointer, it can&rsquo;t be shared across threads. This guarantees that all allocations will be sequential and thus safe since they&rsquo;ll never overlap. This kind of arena shines in parsers, compilers, game engines, and other “scratch memory” use cases.</p>
<hr>
<h2 id="pointer-bumping">Pointer bumping</h2>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#af3a03">impl</span> Arena {
</span></span><span style="display:flex;"><span>    <span style="color:#af3a03">pub</span> <span style="color:#af3a03">fn</span> <span style="color:#b57614">allocate</span><span style="color:#af3a03">&lt;</span>T: <span style="color:#b57614">Copy</span><span style="color:#af3a03">&gt;</span>(<span style="color:#b57614">self</span>: <span style="color:#af3a03">&amp;</span>Rc<span style="color:#af3a03">&lt;</span><span style="color:#b57614">Self</span><span style="color:#af3a03">&gt;</span>, len: <span style="color:#b57614">usize</span>) -&gt; <span style="color:#b57614">Option</span><span style="color:#af3a03">&lt;</span>Allocated<span style="color:#af3a03">&lt;</span>T<span style="color:#af3a03">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#af3a03">let</span> size <span style="color:#af3a03">=</span> core::mem::size_of::<span style="color:#af3a03">&lt;</span>T<span style="color:#af3a03">&gt;</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#af3a03">let</span> align <span style="color:#af3a03">=</span> core::mem::align_of::<span style="color:#af3a03">&lt;</span>T<span style="color:#af3a03">&gt;</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#af3a03">let</span> current_position <span style="color:#af3a03">=</span> <span style="color:#b57614">self</span>.current_position();
</span></span><span style="display:flex;"><span>        <span style="color:#af3a03">let</span> aligned_position <span style="color:#af3a03">=</span> (current_position <span style="color:#af3a03">+</span> align <span style="color:#af3a03">-</span> <span style="color:#8f3f71">1</span>) <span style="color:#af3a03">&amp;</span> <span style="color:#af3a03">!</span>(align <span style="color:#af3a03">-</span> <span style="color:#8f3f71">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#af3a03">let</span> new_position <span style="color:#af3a03">=</span> aligned_position <span style="color:#af3a03">+</span> (size <span style="color:#af3a03">*</span> len);
</span></span><span style="display:flex;"><span>        <span style="color:#af3a03">let</span> buffer <span style="color:#af3a03">=</span> <span style="color:#b57614">self</span>.buffer();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#af3a03">if</span> new_position <span style="color:#af3a03">&lt;=</span> buffer.len() {
</span></span><span style="display:flex;"><span>            <span style="color:#b57614">self</span>.seek(new_position);
</span></span><span style="display:flex;"><span>            <span style="color:#b57614">Some</span>(Allocated {
</span></span><span style="display:flex;"><span>                arena: Rc::downgrade(<span style="color:#b57614">self</span>),
</span></span><span style="display:flex;"><span>                offset: aligned_position,
</span></span><span style="display:flex;"><span>                len,
</span></span><span style="display:flex;"><span>                marker: PhantomData,
</span></span><span style="display:flex;"><span>            })
</span></span><span style="display:flex;"><span>        } <span style="color:#af3a03">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#b57614">None</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#af3a03">pub</span> <span style="color:#af3a03">fn</span> <span style="color:#b57614">buffer</span>(<span style="color:#af3a03">&amp;</span><span style="color:#b57614">self</span>) -&gt; <span style="color:#af3a03">&amp;</span>[<span style="color:#b57614">u8</span>] {
</span></span><span style="display:flex;"><span>        <span style="color:#af3a03">&amp;</span><span style="color:#b57614">self</span>.buffer[<span style="color:#af3a03">..</span>]
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#af3a03">pub</span> <span style="color:#af3a03">fn</span> <span style="color:#b57614">current_position</span>(<span style="color:#af3a03">&amp;</span><span style="color:#b57614">self</span>) -&gt; <span style="color:#b57614">usize</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#b57614">self</span>.cursor.get()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#af3a03">pub</span> <span style="color:#af3a03">fn</span> <span style="color:#b57614">seek</span>(<span style="color:#af3a03">&amp;</span><span style="color:#b57614">self</span>, position: <span style="color:#b57614">usize</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#b57614">self</span>.cursor.set(position);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#af3a03">pub</span> <span style="color:#af3a03">fn</span> <span style="color:#b57614">rewind</span>(<span style="color:#af3a03">&amp;</span><span style="color:#b57614">self</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#b57614">self</span>.seek(<span style="color:#8f3f71">0</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#af3a03">pub</span> <span style="color:#af3a03">fn</span> <span style="color:#b57614">reset</span>(<span style="color:#b57614">self</span>: <span style="color:#af3a03">&amp;</span>mut Rc<span style="color:#af3a03">&lt;</span>Arena<span style="color:#af3a03">&gt;</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#af3a03">if</span> <span style="color:#af3a03">let</span> <span style="color:#b57614">Some</span>(a) <span style="color:#af3a03">=</span> Rc::get_mut(<span style="color:#b57614">self</span>) {
</span></span><span style="display:flex;"><span>            a.buffer.fill(<span style="color:#8f3f71">0</span>);
</span></span><span style="display:flex;"><span>            a.rewind();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Allocating is just math.</p>
<p>Given a type <code>T</code> and a count <code>n</code>, we:</p>
<ol>
<li>Figure out how big <code>T</code> is</li>
<li>Figure out its alignment</li>
<li>Round the cursor <em>up</em> to the next aligned address</li>
<li>Check if it still fits in the buffer</li>
<li>Move the cursor forward and return the slice</li>
</ol>
<p>The alignment step is a simple bit-twiddling trick:</p>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#af3a03">let</span> aligned <span style="color:#af3a03">=</span> (pos <span style="color:#af3a03">+</span> align <span style="color:#af3a03">-</span> <span style="color:#8f3f71">1</span>) <span style="color:#af3a03">&amp;</span> <span style="color:#af3a03">!</span>(align <span style="color:#af3a03">-</span> <span style="color:#8f3f71">1</span>);
</span></span></code></pre></div><p>It looks funky, but it just means “next multiple of <code>align</code>”.</p>
<p>If the allocation would overflow the buffer, we return <code>None</code>. No surprises.</p>
<hr>
<h2 id="why-t-copy">Why <code>T: Copy</code>?</h2>
<p>You’ll notice allocations are restricted to <code>T: Copy</code>.</p>
<p>This arena:</p>
<ul>
<li>does not track individual allocations</li>
<li>does not run destructors</li>
<li>does not know when a value is “done”</li>
</ul>
<p>Letting non-<code>Copy</code> types in here would be a trap. You’d either leak resources or accidentally reuse memory containing values that still think they’re alive.</p>
<p>So the rule is simple:</p>
<blockquote>
<p>If it needs <code>Drop</code>, it doesn’t belong here.</p>
</blockquote>
<p>This makes the arena perfect for:</p>
<ul>
<li>numbers</li>
<li>POD structs</li>
<li>raw buffers</li>
<li>temporary working memory</li>
</ul>
<p>And very bad for things like <code>Vec</code>, <code>String</code>, or reference-owning types.</p>
<p>That’s a good line to draw.</p>
<hr>
<h2 id="dribbling-the-borrow-checker">Dribbling the borrow checker</h2>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#427b58">#[derive(Debug, Clone)]</span>
</span></span><span style="display:flex;"><span><span style="color:#af3a03">pub</span> <span style="color:#af3a03">struct</span> Allocated<span style="color:#af3a03">&lt;</span>T<span style="color:#af3a03">&gt;</span> {
</span></span><span style="display:flex;"><span>    arena: Weak<span style="color:#af3a03">&lt;</span>Arena<span style="color:#af3a03">&gt;</span>,
</span></span><span style="display:flex;"><span>    offset: <span style="color:#b57614">usize</span>,
</span></span><span style="display:flex;"><span>    len: <span style="color:#b57614">usize</span>,
</span></span><span style="display:flex;"><span>    marker: PhantomData<span style="color:#af3a03">&lt;</span>T<span style="color:#af3a03">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#af3a03">impl</span><span style="color:#af3a03">&lt;</span>T<span style="color:#af3a03">&gt;</span> Deref <span style="color:#af3a03">for</span> Allocated<span style="color:#af3a03">&lt;</span>T<span style="color:#af3a03">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#af3a03">type</span> Target <span style="color:#af3a03">=</span> [T];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#af3a03">fn</span> <span style="color:#b57614">deref</span>(<span style="color:#af3a03">&amp;</span><span style="color:#b57614">self</span>) -&gt; <span style="color:#af3a03">&amp;</span>Self::Target {
</span></span><span style="display:flex;"><span>        <span style="color:#af3a03">match</span> <span style="color:#b57614">self</span>.arena.upgrade() {
</span></span><span style="display:flex;"><span>            <span style="color:#b57614">Some</span>(a) <span style="color:#af3a03">=&gt;</span> <span style="color:#af3a03">unsafe</span> {
</span></span><span style="display:flex;"><span>                std::slice::from_raw_parts(
</span></span><span style="display:flex;"><span>                    <span style="color:#af3a03">&amp;</span>a.buffer()[<span style="color:#b57614">self</span>.offset] <span style="color:#af3a03">as</span> <span style="color:#af3a03">*</span><span style="color:#af3a03">const</span> <span style="color:#b57614">u8</span> <span style="color:#af3a03">as</span> <span style="color:#af3a03">*</span><span style="color:#af3a03">const</span> T,
</span></span><span style="display:flex;"><span>                    <span style="color:#b57614">self</span>.len,
</span></span><span style="display:flex;"><span>                )
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>            <span style="color:#b57614">None</span> <span style="color:#af3a03">=&gt;</span> <span style="color:#af3a03">&amp;</span>[],
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#af3a03">impl</span><span style="color:#af3a03">&lt;</span>T<span style="color:#af3a03">&gt;</span> DerefMut <span style="color:#af3a03">for</span> Allocated<span style="color:#af3a03">&lt;</span>T<span style="color:#af3a03">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#af3a03">fn</span> <span style="color:#b57614">deref_mut</span>(<span style="color:#af3a03">&amp;</span><span style="color:#af3a03">mut</span> <span style="color:#b57614">self</span>) -&gt; <span style="color:#af3a03">&amp;</span>mut <span style="color:#b57614">Self</span>::Target {
</span></span><span style="display:flex;"><span>        <span style="color:#af3a03">match</span> <span style="color:#b57614">self</span>.arena.upgrade() {
</span></span><span style="display:flex;"><span>            <span style="color:#b57614">Some</span>(a) <span style="color:#af3a03">=&gt;</span> <span style="color:#af3a03">unsafe</span> {
</span></span><span style="display:flex;"><span>                std::slice::from_raw_parts_mut(
</span></span><span style="display:flex;"><span>                    <span style="color:#af3a03">&amp;</span>a.buffer()[<span style="color:#b57614">self</span>.offset] <span style="color:#af3a03">as</span> <span style="color:#af3a03">*</span><span style="color:#af3a03">const</span> <span style="color:#b57614">u8</span> <span style="color:#af3a03">as</span> <span style="color:#af3a03">*</span><span style="color:#af3a03">mut</span> T,
</span></span><span style="display:flex;"><span>                    <span style="color:#b57614">self</span>.len,
</span></span><span style="display:flex;"><span>                )
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>            <span style="color:#b57614">None</span> <span style="color:#af3a03">=&gt;</span> <span style="color:#af3a03">&amp;</span><span style="color:#af3a03">mut</span> [],
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>One tricky part of arena design in Rust is <em>returning references</em>.</p>
<p>If <code>allocate()</code> returned <code>&amp;mut [T]</code>, the borrow checker would immediately block you from making a second allocation while that slice exists. That defeats the whole point of an arena.</p>
<p>This implementation sidesteps that by returning an <code>Allocated&lt;T&gt;</code> instead.</p>
<p>An <code>Allocated&lt;T&gt;</code> doesn’t <em>borrow</em> the arena. Instead, it stores:</p>
<ul>
<li>a <code>Weak&lt;Arena&gt;</code></li>
<li>an offset into the buffer</li>
<li>a length</li>
<li>a marker to make the compiler believe it can be a <code>T</code></li>
</ul>
<p>When dereferenced, it:</p>
<ol>
<li>upgrades the <code>Weak</code> to an <code>Rc</code></li>
<li>computes the pointer into the buffer</li>
<li>creates a slice on the fly</li>
</ol>
<p>If the arena is already gone, you just get an empty slice. Is this “less strict” than normal Rust borrowing? Yes. Is it reasonable for a low-level memory tool? Yes. Since we&rsquo;ve done the work to ensure our code is safe, we can trade off this compile-time check for a small runtime check and gain increased performance.</p>
<hr>
<h2 id="turning-bytes-into-t">Turning bytes into <code>&amp;[T]</code></h2>
<p>At some point, bytes have to become typed values. This is the unsafe core of the allocator.</p>
<p>The arena:</p>
<ul>
<li>computes a byte offset</li>
<li>casts a <code>*const u8</code> to <code>*const T</code></li>
<li>builds a slice with <code>from_raw_parts</code></li>
</ul>
<p>This is where the invariants matter:</p>
<ul>
<li>the offset must be aligned</li>
<li>the memory must be in bounds</li>
<li>the bytes must represent valid <code>T</code>s</li>
</ul>
<p>The first two are handled by the allocator. The third is on the user. That’s why <code>T: Copy</code> matters. This arena assumes you know what bit patterns you’re writing. If you treat it like a bag of bytes, you’re fine.</p>
<hr>
<h2 id="sub-arenas-arenas-inside-arenas">Sub-arenas: arenas inside arenas</h2>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#427b58">#[derive(Debug)]</span>
</span></span><span style="display:flex;"><span><span style="color:#af3a03">pub</span> <span style="color:#af3a03">struct</span> SubArena {
</span></span><span style="display:flex;"><span>    backing_arena: Rc<span style="color:#af3a03">&lt;</span>Arena<span style="color:#af3a03">&gt;</span>,
</span></span><span style="display:flex;"><span>    offset: <span style="color:#b57614">usize</span>,
</span></span><span style="display:flex;"><span>    len: <span style="color:#b57614">usize</span>,
</span></span><span style="display:flex;"><span>    cursor: Cell<span style="color:#af3a03">&lt;</span><span style="color:#b57614">usize</span><span style="color:#af3a03">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#af3a03">impl</span> Arena {
</span></span><span style="display:flex;"><span>	<span style="color:#af3a03">pub</span> <span style="color:#af3a03">fn</span> <span style="color:#b57614">sub_arena</span>(<span style="color:#b57614">self</span>: <span style="color:#af3a03">&amp;</span>Rc<span style="color:#af3a03">&lt;</span>Arena<span style="color:#af3a03">&gt;</span>, len: <span style="color:#b57614">usize</span>) -&gt; <span style="color:#b57614">Option</span><span style="color:#af3a03">&lt;</span>SubArena<span style="color:#af3a03">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#af3a03">let</span> offset <span style="color:#af3a03">=</span> <span style="color:#b57614">self</span>.current_position();
</span></span><span style="display:flex;"><span>        <span style="color:#af3a03">let</span> new_offset <span style="color:#af3a03">=</span> offset <span style="color:#af3a03">+</span> len;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#af3a03">if</span> new_offset <span style="color:#af3a03">&lt;=</span> <span style="color:#b57614">self</span>.buffer().len() {
</span></span><span style="display:flex;"><span>            <span style="color:#b57614">self</span>.seek(new_offset);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#b57614">Some</span>(SubArena {
</span></span><span style="display:flex;"><span>                backing_arena: Rc::clone(<span style="color:#b57614">self</span>),
</span></span><span style="display:flex;"><span>                offset,
</span></span><span style="display:flex;"><span>                len,
</span></span><span style="display:flex;"><span>                cursor: Cell::new(<span style="color:#8f3f71">0</span>),
</span></span><span style="display:flex;"><span>            })
</span></span><span style="display:flex;"><span>        } <span style="color:#af3a03">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#b57614">None</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#af3a03">impl</span> SubArena {
</span></span><span style="display:flex;"><span>    <span style="color:#af3a03">pub</span> <span style="color:#af3a03">fn</span> <span style="color:#b57614">allocate</span><span style="color:#af3a03">&lt;</span>T: <span style="color:#b57614">Copy</span><span style="color:#af3a03">&gt;</span>(<span style="color:#af3a03">&amp;</span><span style="color:#b57614">self</span>, count: <span style="color:#b57614">usize</span>) -&gt; <span style="color:#b57614">Option</span><span style="color:#af3a03">&lt;</span>Allocated<span style="color:#af3a03">&lt;</span>T<span style="color:#af3a03">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#af3a03">let</span> size <span style="color:#af3a03">=</span> core::mem::size_of::<span style="color:#af3a03">&lt;</span>T<span style="color:#af3a03">&gt;</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#af3a03">let</span> align <span style="color:#af3a03">=</span> core::mem::align_of::<span style="color:#af3a03">&lt;</span>T<span style="color:#af3a03">&gt;</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#af3a03">let</span> current_position <span style="color:#af3a03">=</span> <span style="color:#b57614">self</span>.current_position();
</span></span><span style="display:flex;"><span>        <span style="color:#af3a03">let</span> aligned_position <span style="color:#af3a03">=</span> (current_position <span style="color:#af3a03">+</span> align <span style="color:#af3a03">-</span> <span style="color:#8f3f71">1</span>) <span style="color:#af3a03">&amp;</span> <span style="color:#af3a03">!</span>(align <span style="color:#af3a03">-</span> <span style="color:#8f3f71">1</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#af3a03">let</span> new_position <span style="color:#af3a03">=</span> aligned_position <span style="color:#af3a03">+</span> (size <span style="color:#af3a03">*</span> count);
</span></span><span style="display:flex;"><span>        <span style="color:#af3a03">let</span> buffer <span style="color:#af3a03">=</span> <span style="color:#b57614">self</span>.buffer();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#af3a03">if</span> new_position <span style="color:#af3a03">&lt;=</span> buffer.len() {
</span></span><span style="display:flex;"><span>            <span style="color:#b57614">self</span>.seek(new_position);
</span></span><span style="display:flex;"><span>            <span style="color:#b57614">Some</span>(Allocated {
</span></span><span style="display:flex;"><span>                arena: Rc::downgrade(<span style="color:#af3a03">&amp;</span><span style="color:#b57614">self</span>.backing_arena),
</span></span><span style="display:flex;"><span>                offset: self.offset <span style="color:#af3a03">+</span> aligned_position,
</span></span><span style="display:flex;"><span>                len: count,
</span></span><span style="display:flex;"><span>                marker: PhantomData,
</span></span><span style="display:flex;"><span>            })
</span></span><span style="display:flex;"><span>        } <span style="color:#af3a03">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#b57614">None</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#af3a03">pub</span> <span style="color:#af3a03">fn</span> <span style="color:#b57614">buffer</span>(<span style="color:#af3a03">&amp;</span><span style="color:#b57614">self</span>) -&gt; <span style="color:#af3a03">&amp;</span>[<span style="color:#b57614">u8</span>] {
</span></span><span style="display:flex;"><span>        <span style="color:#af3a03">let</span> start <span style="color:#af3a03">=</span> <span style="color:#b57614">self</span>.offset;
</span></span><span style="display:flex;"><span>        <span style="color:#af3a03">let</span> end <span style="color:#af3a03">=</span> start <span style="color:#af3a03">+</span> <span style="color:#b57614">self</span>.len;
</span></span><span style="display:flex;"><span>        <span style="color:#af3a03">&amp;</span><span style="color:#b57614">self</span>.backing_arena.buffer[start<span style="color:#af3a03">..</span>end]
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#af3a03">pub</span> <span style="color:#af3a03">fn</span> <span style="color:#b57614">current_position</span>(<span style="color:#af3a03">&amp;</span><span style="color:#b57614">self</span>) -&gt; <span style="color:#b57614">usize</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#b57614">self</span>.cursor.get()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#af3a03">pub</span> <span style="color:#af3a03">fn</span> <span style="color:#b57614">seek</span>(<span style="color:#af3a03">&amp;</span><span style="color:#b57614">self</span>, position: <span style="color:#b57614">usize</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#b57614">self</span>.cursor.set(position);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#af3a03">pub</span> <span style="color:#af3a03">fn</span> <span style="color:#b57614">rewind</span>(<span style="color:#af3a03">&amp;</span><span style="color:#b57614">self</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#b57614">self</span>.seek(<span style="color:#8f3f71">0</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#af3a03">pub</span> <span style="color:#af3a03">fn</span> <span style="color:#b57614">reset</span>(<span style="color:#af3a03">&amp;</span><span style="color:#b57614">self</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#b57614">self</span>.rewind();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#af3a03">let</span> <span style="color:#af3a03">mut</span> buffer <span style="color:#af3a03">=</span> <span style="color:#b57614">self</span>
</span></span><span style="display:flex;"><span>            .allocate::<span style="color:#af3a03">&lt;</span><span style="color:#b57614">u8</span><span style="color:#af3a03">&gt;</span>(<span style="color:#b57614">self</span>.len)
</span></span><span style="display:flex;"><span>            .expect(<span style="color:#79740e">&#34;Unable to allocate whole buffer&#34;</span>);
</span></span><span style="display:flex;"><span>        buffer.fill(<span style="color:#8f3f71">0</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#b57614">self</span>.rewind();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Sometimes you want structure. Instead of allocating everything from one flat space, you might want a temporary region you can blow away independently. That’s what <code>SubArena</code> is for.</p>
<p>A sub-arena:</p>
<ul>
<li>reserves a chunk from the parent arena once</li>
<li>maintains its own local cursor inside that region</li>
<li>allocates without touching the parent again</li>
</ul>
<p>Think of it as carving out a “workspace”:</p>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>[ parent arena ]
</span></span><span style="display:flex;"><span>|---- general stuff ----|---- sub arena ----|
</span></span><span style="display:flex;"><span>                         ^ local allocations happen here
</span></span></code></pre></div><p>When you’re done, you just rewind or reset the sub-arena. No coordination with the parent required.</p>
<p>This pattern is great for:</p>
<ul>
<li>recursive algorithms</li>
<li>parsing phases</li>
<li>temporary scratch buffers</li>
</ul>
<hr>
<h2 id="treating-allocations-like-io-buffers">Treating allocations like I/O buffers</h2>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#af3a03">impl</span><span style="color:#af3a03">&lt;</span>T<span style="color:#af3a03">&gt;</span> <span style="color:#b57614">AsRef</span><span style="color:#af3a03">&lt;</span>[<span style="color:#b57614">u8</span>]<span style="color:#af3a03">&gt;</span> <span style="color:#af3a03">for</span> Allocated<span style="color:#af3a03">&lt;</span>T<span style="color:#af3a03">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#af3a03">fn</span> <span style="color:#b57614">as_ref</span>(<span style="color:#af3a03">&amp;</span><span style="color:#b57614">self</span>) -&gt; <span style="color:#af3a03">&amp;</span>[<span style="color:#b57614">u8</span>] {
</span></span><span style="display:flex;"><span>        <span style="color:#af3a03">match</span> <span style="color:#b57614">self</span>.arena.upgrade() {
</span></span><span style="display:flex;"><span>            <span style="color:#b57614">Some</span>(a) <span style="color:#af3a03">=&gt;</span> <span style="color:#af3a03">unsafe</span> {
</span></span><span style="display:flex;"><span>                std::slice::from_raw_parts(
</span></span><span style="display:flex;"><span>                    <span style="color:#af3a03">&amp;</span>a.buffer()[<span style="color:#b57614">self</span>.offset] <span style="color:#af3a03">as</span> <span style="color:#af3a03">*</span><span style="color:#af3a03">const</span> <span style="color:#b57614">u8</span>,
</span></span><span style="display:flex;"><span>                    <span style="color:#b57614">self</span>.len <span style="color:#af3a03">*</span> std::mem::size_of::<span style="color:#af3a03">&lt;</span>T<span style="color:#af3a03">&gt;</span>(),
</span></span><span style="display:flex;"><span>                )
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>            <span style="color:#b57614">None</span> <span style="color:#af3a03">=&gt;</span> <span style="color:#af3a03">&amp;</span>[],
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#af3a03">impl</span><span style="color:#af3a03">&lt;</span>T<span style="color:#af3a03">&gt;</span> <span style="color:#b57614">AsMut</span><span style="color:#af3a03">&lt;</span>[<span style="color:#b57614">u8</span>]<span style="color:#af3a03">&gt;</span> <span style="color:#af3a03">for</span> Allocated<span style="color:#af3a03">&lt;</span>T<span style="color:#af3a03">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#af3a03">fn</span> <span style="color:#b57614">as_mut</span>(<span style="color:#af3a03">&amp;</span><span style="color:#af3a03">mut</span> <span style="color:#b57614">self</span>) -&gt; <span style="color:#af3a03">&amp;</span>mut [<span style="color:#b57614">u8</span>] {
</span></span><span style="display:flex;"><span>        <span style="color:#af3a03">match</span> <span style="color:#b57614">self</span>.arena.upgrade() {
</span></span><span style="display:flex;"><span>            <span style="color:#b57614">Some</span>(a) <span style="color:#af3a03">=&gt;</span> <span style="color:#af3a03">unsafe</span> {
</span></span><span style="display:flex;"><span>                std::slice::from_raw_parts_mut(
</span></span><span style="display:flex;"><span>                    <span style="color:#af3a03">&amp;</span>a.buffer()[<span style="color:#b57614">self</span>.offset] <span style="color:#af3a03">as</span> <span style="color:#af3a03">*</span><span style="color:#af3a03">const</span> <span style="color:#b57614">u8</span> <span style="color:#af3a03">as</span> <span style="color:#af3a03">*</span><span style="color:#af3a03">mut</span> <span style="color:#b57614">u8</span>,
</span></span><span style="display:flex;"><span>                    <span style="color:#b57614">self</span>.len <span style="color:#af3a03">*</span> std::mem::size_of::<span style="color:#af3a03">&lt;</span>T<span style="color:#af3a03">&gt;</span>(),
</span></span><span style="display:flex;"><span>                )
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>            <span style="color:#b57614">None</span> <span style="color:#af3a03">=&gt;</span> <span style="color:#af3a03">&amp;</span><span style="color:#af3a03">mut</span> [],
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#af3a03">impl</span><span style="color:#af3a03">&lt;</span>T<span style="color:#af3a03">&gt;</span> Read <span style="color:#af3a03">for</span> Allocated<span style="color:#af3a03">&lt;</span>T<span style="color:#af3a03">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#af3a03">fn</span> <span style="color:#b57614">read</span>(<span style="color:#af3a03">&amp;</span><span style="color:#af3a03">mut</span> <span style="color:#b57614">self</span>, buf: <span style="color:#af3a03">&amp;</span>mut [<span style="color:#b57614">u8</span>]) -&gt; io::<span style="color:#b57614">Result</span><span style="color:#af3a03">&lt;</span><span style="color:#b57614">usize</span><span style="color:#af3a03">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#af3a03">let</span> inner <span style="color:#af3a03">=</span> <span style="color:#b57614">self</span>.as_ref();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#af3a03">if</span> inner.len() <span style="color:#af3a03">==</span> buf.len() {
</span></span><span style="display:flex;"><span>            buf.copy_from_slice(inner);
</span></span><span style="display:flex;"><span>            <span style="color:#b57614">Ok</span>(inner.len())
</span></span><span style="display:flex;"><span>        } <span style="color:#af3a03">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#b57614">Err</span>(io::Error::other(<span style="color:#79740e">&#34;Buffer not same size&#34;</span>))
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#af3a03">impl</span><span style="color:#af3a03">&lt;</span>T<span style="color:#af3a03">&gt;</span> Write <span style="color:#af3a03">for</span> Allocated<span style="color:#af3a03">&lt;</span>T<span style="color:#af3a03">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#af3a03">fn</span> <span style="color:#b57614">write</span>(<span style="color:#af3a03">&amp;</span><span style="color:#af3a03">mut</span> <span style="color:#b57614">self</span>, buf: <span style="color:#af3a03">&amp;</span>[<span style="color:#b57614">u8</span>]) -&gt; io::<span style="color:#b57614">Result</span><span style="color:#af3a03">&lt;</span><span style="color:#b57614">usize</span><span style="color:#af3a03">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#af3a03">let</span> inner <span style="color:#af3a03">=</span> <span style="color:#b57614">self</span>.as_mut();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#af3a03">if</span> inner.len() <span style="color:#af3a03">==</span> buf.len() {
</span></span><span style="display:flex;"><span>            inner.copy_from_slice(buf);
</span></span><span style="display:flex;"><span>            <span style="color:#b57614">Ok</span>(inner.len())
</span></span><span style="display:flex;"><span>        } <span style="color:#af3a03">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#b57614">Err</span>(io::Error::other(<span style="color:#79740e">&#34;Buffer not same size&#34;</span>))
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#af3a03">fn</span> <span style="color:#b57614">flush</span>(<span style="color:#af3a03">&amp;</span><span style="color:#af3a03">mut</span> <span style="color:#b57614">self</span>) -&gt; io::<span style="color:#b57614">Result</span><span style="color:#af3a03">&lt;</span>()<span style="color:#af3a03">&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#b57614">Ok</span>(())
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Since we store everything as raw bytes: an allocation can double as an I/O buffer. By implementing the following traits on <code>Allocated&lt;T&gt;</code>:</p>
<ul>
<li><code>AsRef&lt;[u8]&gt;</code></li>
<li><code>AsMut&lt;[u8]&gt;</code></li>
<li><code>Read</code></li>
<li><code>Write</code></li>
</ul>
<p>We can use it like this.</p>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#af3a03">let</span> <span style="color:#af3a03">mut</span> buf <span style="color:#af3a03">=</span> arena.allocate::<span style="color:#af3a03">&lt;</span><span style="color:#b57614">u8</span><span style="color:#af3a03">&gt;</span>(<span style="color:#8f3f71">1024</span>).unwrap();
</span></span><span style="display:flex;"><span>file.read_exact(buf.as_mut())<span style="color:#af3a03">?</span>;
</span></span></code></pre></div><p>No extra heap allocations. No temporary <code>Vec&lt;u8&gt;</code>. Just write straight into arena memory.</p>
<p>The <code>Read</code> and <code>Write</code> implementations are intentionally strict—they only succeed if the sizes match exactly, keeping bugs loud.</p>
<hr>
<h2 id="resetting-rewinding-starting-over">Resetting, rewinding, starting over</h2>
<p>Since the arena never frees individual allocations, cleanup is simple:</p>
<ul>
<li><code>rewind()</code> sets the cursor back to zero</li>
<li><code>reset()</code> clears memory and rewinds</li>
</ul>
<p>This makes arenas perfect for phase-based work:</p>
<div class="highlight"><pre tabindex="0" style="color:#3c3836;background-color:#fbf1c7;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>allocate a bunch → do work → reset → repeat
</span></span></code></pre></div><p>No fragmentation, no surprises.</p>
<hr>
<h2 id="what-this-arena-is-and-isnt">What this arena is (and isn’t)</h2>
<p>This arena is:</p>
<ul>
<li>fast</li>
<li>simple</li>
<li>predictable</li>
<li>great for temporary memory</li>
</ul>
<p>It is not:</p>
<ul>
<li>a general allocator</li>
<li>thread-safe</li>
<li>destructor-aware</li>
<li>a good place for owning data structures</li>
</ul>
<p>That’s not a weakness. That’s the point. Manual memory management is about <em>trade-offs</em>.</p>

        </section>
        <div class="post-tags">
          
          
          <nav class="nav tags">
            <ul class="tags">
              
              <li><a href="/en/tags/programming/">programming</a></li>
              
              <li><a href="/en/tags/rust/">rust</a></li>
              
              <li><a href="/en/tags/memory-management/">memory-management</a></li>
              
              <li><a href="/en/tags/arena/">arena</a></li>
              
              <li><a href="/en/tags/pointers/">pointers</a></li>
              
            </ul>
          </nav>
          
          
        </div>
      </div>

      
      
    </div>

    </article>
</main>
<footer>
  <div style="display:flex"><a class="soc" href="https://github.com/ebalbino" rel="me" title="GitHub"><svg class="feather">
       <use href="/svg/feather-sprite.51cf5647cb1987f769b616558f2620fd9423d72058490231b391bf6aa3744b55.svg#github" />
    </svg></a><a class="border"></a></div>
  <div class="footer-info">
    2026  © Ed Balbino 
  </div>
</footer>



</div>
    </body>
</html>
